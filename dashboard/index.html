<html>
  <head>
    <title>{{.Name}} - Metrics Dashboard</title>
    <style>
      * {
        font-family: sans-serif;
        font-size: 10pt;
      }

      tr:nth-child(even){
        background-color:#e0e0e0
      }

      table {
        border-collapse: collapse;
      }

      td,th {
        border-left: 1px solid black;
        padding-left: 3px;
        padding-right: 3px;
      }

      th:first-child,
      td:first-child{
        border-left: 0;
      }

      div.horizon > canvas {
        display: block;
      }
      div.horizon > span.value {
        position: relative;
        left: 20px;
      }

      div.graph{
        float: left;
        width: 400px;
      }

      canvas#heatmap{
        padding-top: 5px;
        padding-bottom: 5px;
      }

    </style>
  </head>
  <body>
    <h3>{{.Name}} - Metrics Dashboard</h3>
    <div id="list"></div>
    <div id="metrics">
      <h3>Counters</h3>
      <table id="counters">
        <tr id="header"><th>Name</th><th>Value</th><th>Updated</th></tr>
      </table>
      <h3>Distributions</h3>
      <table id="distributions">
        <tr id="header">
          <th>Name</th>
          <th>Count</th>
          <th>Mean</th>
          <th>Variance</th>
          <th>StdDev</th>
          <th>Skewness</th>
          <th>Kurtosis</th>
          <th>Min</th>
          <th>Max</th>
          <th>Median</th>
          <th>25%</th>
          <th>75%</th>
          <th>95%</th>
          <th>99%</th>
          <th>99.9%</th>
        </tr>
      </table>
      <h3>Gauges</h3>
      <table id="gauges">
        <tr id="header"><th>Name</th><th>Value</th><th>Updated</th></tr>
      </table>
      <h3>Meters</h3>
      <table id="meters">
        <tr id="header">
          <th>Name</th><th>Value</th><th>1 min</th>
          <th>5 min</th><th>15 min</th><th>Rates</th>
          <th>1 min</th><th>5 min</th><th>15 min</th>
          <th>Updated</th>
        </tr>
      </table>
    </div>
    <h3>Graphs</h3>
    <div id="graphs"></div>
    <script src="http://d3js.org/d3.v2.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script src="https://raw.github.com/jasondavies/science.js/master/science.v1.min.js"></script>
    <script src="http://square.github.com/cubism/cubism.v1.js"></script>
    <script src="http://masonry.desandro.com/jquery.masonry.min.js"></script>
    <script>


var tableInterval = 1000,
KDEInterval = 10000,
heatmapInterval = 1000

function MetricRow(name){
  var graphs = {}
  var graphcount = 0
  var graphdiv = d3.select("#graphs").append("div").attr("class", "graph")
  var data

  this.row = null
  this.name = name

  this.setData = function(a){
    data = a
  }

  // a reference to actual data variable, not the object in it
  this.getDataFunc = function(){
    return function(){return data}
  }

  this.drawRow = function(vals){
    var cells = this.row.selectAll("td").data(vals)
    cells.enter().append("td")
    cells.each(function(d){
      cell = d3.select(this)
      if($.isFunction(d)){
        d(cell)
      } else {
        if($.isNumeric(d))
          d = formatFixedLen(d)
        cell.text(d)
      }
    })
  }

  this.clickableCell = function(onclick){
    return function(cell){
      cell.on("click", function(){onclick(cell)})
    }
  }

  this.graphToggle = function(graphname, accessor, Constructor, color){
    return this.clickableCell(function(cell){
      if(graphs[graphname] != null){
        graphcount--
        if(graphcount == 0){
          graphdiv.style("padding", "0")
          graphdiv.select("h3#title").remove()
        }

        graphs[graphname].destroy()
        delete graphs[graphname]

        cell.style("background-color", "transparent")
      } else {
        if(graphcount == 0){
          graphdiv.style("padding", "5px")
          graphdiv.append("h3").attr("id", "title").text(name)
        }
        graphcount++

        graphs[graphname] = new Constructor(graphname, accessor, graphdiv)

        cell.style("background-color", color)
      }
      $("#graphs").masonry("reload")
    })
  }
}

MetricRowUpdater.metrics = []

function MetricRowUpdater(name, type){
  var row
  switch(type){
  case "counter":
    row = new CounterRow(name)
    break
  case "distribution":
    row = new DistributionRow(name)
    break
  case "gauge":
    row = new GaugeRow(name)
    break
  case "meter":
    row = new MeterRow(name)
    break
  }

  this.update = function(){
    $.getJSON("/metric", {"name" : name},
    function(d){
      row.metric.setData(d.Value)
      row.draw()
    })
  }

  MetricRowUpdater.metrics.push(this)
}

MetricRowUpdater.updateAll = function(){
  metrics = MetricRowUpdater.metrics
  for(i in metrics){
    metrics[i].update()
  }
}


function CounterRow(name){
  this.name = name
  this.metric = new MetricRow(name)
  var data = this.metric.getDataFunc()

  this.draw = function(){
    var updated = new Date(data().LastUpdated)
    var row = [
      this.name,
      data().Value,
      updated.toLocaleTimeString()
    ]

    this.metric.drawRow(row)
  }

  this.makeToggles = function(){
    var row = [
      null,
      this.metric.graphToggle("Value", function(){return data().Value},
        CubismGraph, "yellow"),
      null
    ]

    this.metric.drawRow(row)
  }

  this.metric.row = d3.select("#counters").append("tr")
  this.makeToggles()
}

function DistributionRow(name){
  this.name = name
  this.metric = new MetricRow(name)
  var data = this.metric.getDataFunc()

  var cubismToggles = [
    ["Mean", function(){return data().Mean}],
    ["Variance", function(){return data().Variance}],
    ["StdDev", function(){return data().StandardDeviation}],
    ["Skewness", function(){return data().Skewness}],
    ["Kurtosis", function(){return data().Kurtosis}],
    ["Min", function(){return data().Percentiles[0]}],
    ["Max", function(){return data().Percentiles[7]}],
    ["Median", function(){return data().Percentiles[2]}],
    ["25%", function(){return data().Percentiles[1]}],
    ["75%", function(){return data().Percentiles[3]}],
    ["95%", function(){return data().Percentiles[4]}],
    ["99%", function(){return data().Percentiles[5]}],
    ["99.9%", function(){return data().Percentiles[6]}],
  ]

  this.draw = function(){
    var name = this.name
    var row = [name, data().Count]
    for(var i = 0; i < cubismToggles.length; i++){
      row.push(cubismToggles[i][1]())
    }

    this.metric.drawRow(row)
  }

  this.makeToggles = function(){
    var name = this.name
    var row = [
      this.metric.graphToggle("heatmap", function(){ return name },
        HeatmapUpdater, "lightgreen"),
      this.metric.graphToggle("samples", function(){ return name },
        KDEGraphUpdater, "lightgreen")
    ]
    for(var i = 0; i < cubismToggles.length; i++){
      row.push(this.metric.graphToggle(cubismToggles[i][0],
        cubismToggles[i][1], CubismGraph, "lightgreen"))
    }

    this.metric.drawRow(row)
  }

  this.metric.row = d3.select("#distributions").append("tr")
  this.makeToggles()
}

function GaugeRow(name){
  this.name = name
  this.metric = new MetricRow(name)
  var data = this.metric.getDataFunc()

  this.draw = function(){
    var updated = new Date(data().LastUpdated)
    var str
    if(data().Value.length > 80) {
      str = slice(data().Value, 77) + "..."
    } else {
      str = data().Value
    }
    this.metric.drawRow([name, str, updated.toLocaleTimeString()])
  }

  this.metric.row = d3.select("#gauges").append("tr")
}

function MeterRow(name){
  this.name = name
  this.metric = new MetricRow(name)
  var data = this.metric.getDataFunc()

  var toggles = [
    ["Value", function(){return data().Value}],
    ["1 min avg", function(){return data().Derivatives[0][1]}],
    ["5 min avg", function(){return data().Derivatives[0][2]}],
    ["15 min avg", function(){return data().Derivatives[0][3]}],
    ["instant rate", function(){return data().Derivatives[1][0]}],
    ["1 min rate", function(){return data().Derivatives[1][1]}],
    ["5 min rate", function(){return data().Derivatives[1][2]}],
    ["15 min rate", function(){return data().Derivatives[1][3]}]
  ]

  this.draw = function(){
    var row = [this.name]
    for(var i = 0; i < toggles.length; i++){
      row.push(toggles[i][1]())
    }
    var updated = new Date(data().LastUpdated)
    row.push(updated.toLocaleTimeString())

    this.metric.drawRow(row)
  }

  this.makeToggles = function(){
    var row = [null]
    for(var i = 0; i < toggles.length; i++){
      row.push(this.metric.graphToggle(toggles[i][0], toggles[i][1],
        CubismGraph, "pink"))
    }
    row.push(null)

    this.metric.drawRow(row)
  }

  this.metric.row = d3.select("#meters").append("tr")
  this.makeToggles()
}

HeatmapUpdater.heatmaps = []

function HeatmapUpdater(name, accessor, div){
  var npreload, heatmap

  this.preload = function(arr){
    var u = this
    $.getJSON("/metric",
      {"name" : accessor(),
       "samples" : true,
       "limit" : 1000},
      function(d){
        var rangeslice = dataRangeSlice(d.Value, 0.2, 0.8, 2)
        range = rangeslice[0]

        heatmap = new Heatmap(div, range)
        npreload = heatmap.getHRes()

        now = new Date
        for(var i = npreload; i >= 0; i--){
          u.update(new Date(now.getTime() - heatmapInterval * i))
        }
    })
  }

  this.update = function(end){
    var begin = new Date(end.getTime() - heatmapInterval)

    var newest = end
    var oldest = new Date(newest.getTime() - (npreload - 1) * heatmapInterval)

    $.getJSON("/metric",
      {"name" : accessor(),
       "samples" : true,
       "limit" : 100,
       "begin" : begin.toISOString(),
       "end" : end.toISOString()},
      function(d){
        heatmap.draw(d.Value, newest, oldest)
      })
  }

  this.preload()

  HeatmapUpdater.heatmaps.push([this, heatmapInterval, 0])

  this.destroy = function(data){
    var h = HeatmapUpdater.heatmaps
    for(i in h){
      if(h[i][0] == this){
        h.splice(i, 1)
        break
      }
    }
    heatmap.destroy()
  }
}

HeatmapUpdater.updateAll = function(){
  var h = HeatmapUpdater.heatmaps
  for(var i in h){
    h[i][2] -= heatmapInterval
    if(h[i][2] <= 0){
      h[i][0].update(new Date)
      h[i][2] = h[i][1]
    }
  }
}

function Heatmap(div, range){
  var w = 345, wmargin = 60, h = 100, hmargin = 20
  var shiftw = 5, nbins = 20

  var elem = div.append("canvas").attr("id", "heatmap")
    .attr("width", w + wmargin).attr("height", h + hmargin)
  var ctx = elem[0][0].getContext('2d')

  var newest = null

  var colormap = function(v){
    var lightness = 15 + 0.6 * v
    var hue = 240 - 3.6 * v
    return "hsl(" + hue + ", 100%, " + lightness + "%)"
  }

  ctx.fillStyle = colormap(0)
  ctx.fillRect(0, 0, w, h)

  this.draw = function(arr, newest, oldest){
    var hist = d3.layout.histogram().range(range).bins(nbins)
    var bins = hist(arr)

    ctx.drawImage(ctx.canvas, shiftw, 0, w - shiftw, h, 0, 0, w - shiftw, h)

    ctx.save()
    ctx.translate(w - shiftw, 0)
    for(var i = 0; i < bins.length; i++){
      ctx.fillStyle = colormap(bins[i].y)
      ctx.fillRect(0, (bins.length - i - 1) * h / nbins, shiftw, h / nbins)
    }
    ctx.restore()

    ctx.save()
    ctx.fillStyle = "black"
    ctx.font = "12px sans-serif"

    // x axis
    ctx.save()
    ctx.translate(0, h)
    ctx.clearRect(0, 0, w, hmargin)

    var mid = new Date((oldest.getTime() + newest.getTime()) / 2)
    ctx.fillText(oldest.toLocaleTimeString(), 0, 15)
    ctx.fillText(mid.toLocaleTimeString(), (w-50)/2, 15)
    ctx.fillText(newest.toLocaleTimeString(), w-50, 15)
    ctx.restore()

    // y axis
    ctx.save()
    ctx.translate(w, 0)
    ctx.clearRect(0, 0, wmargin, h)
    ctx.fillText(formatFixedLen(range[1]), 5, 12)
    ctx.fillText(formatFixedLen((range[0] + range[1])/2),
      5, Math.floor((h + 10)/2))
    ctx.fillText(formatFixedLen(range[0]), 5, h - 2)
    ctx.restore()
    ctx.restore()
  }

  this.getHRes = function(){
    return w/shiftw
  }

  this.destroy = function(data){
    elem.remove()
  }
}

var cubismContext = cubism.context()
    .serverDelay(1000).step(tableInterval).size(400)

function CubismGraph(name, accessor, div){
  var context = cubismContext

  // Force Cubism to synchronously update
  // Cubism reads with start incrementing by step,
  // and stop = start + 6*step. So, it reads everything
  // 7 times. This is not good since the previous values
  // aren't stored on the server.
  var queue = []
  var metric = context.metric(
    function(start, stop, step, callback){
      start = +start
      stop = +stop

      var res = []

      queue.push(accessor())
      if(queue.length > 7)
        queue.shift()

      while(start < stop){
        start += step
        res.push(queue[i])
      }
      callback(null, res)
    }, name)


  var graph = div.append("div").attr("id", name)

  var axis = graph.append("div").attr("class", "axis")
    .call(context.axis().ticks(d3.time.minutes, 2).orient("top"))

  var horizon = graph.selectAll(".horizon")
    .data([metric]).enter()
    .append("div")
    .attr("class", "horizon")
    .call(context.horizon())

  var rule = graph.append("div").data([]).attr("class", "rule")
    .call(context.rule())

  this.destroy = function(){
    graph.select(".axis")
      .call(context.axis().remove).remove()
    graph.select(".horizon")
      .call(context.horizon().remove).remove()
    graph.select(".rule")
      .call(context.rule().remove).remove()
    graph.remove()
  }
}

function KDEGraphUpdater(name, accessor, div){
  var graph = new KDEGraph(div)

  this.update = function(){
    $.getJSON("/metric",
      {"name" : accessor(), "samples" : true, "limit" : 1000},
      function(d){ graph.draw(d.Value) })
  }
  this.update()

  KDEGraphUpdater.graphs.push(this)

  this.destroy = function(){
    graph.destroy()
  }
}

KDEGraphUpdater.graphs = []

function KDEGraph(div){
  var svg = div.append("svg").attr("id", "samples")
  var path = svg.append("path").style("fill", "steelblue")
  var xgroup = svg.append("g").attr("id", "xlabel")

  var w = 345, h = 240, wmargin = 55, hmargin = 40

  this.draw = function(data){
    svg.attr("width", w + wmargin)
      .attr("height", h + hmargin)

    var rangeslice = dataRangeSlice(data, 0.1, 0.9, 2)
    var range = rangeslice[0]
    var slice = rangeslice[1]

    var diff = range[1] - range[0]

    var kde = science.stats.kde().sample(slice)
    kde.bandwidth(science.stats.bandwidth.nrd0)
    var kdearr = kde(d3.range(range[0], range[1] + diff/2/w, diff/w))


    ymax = d3.max(kdearr, function(d){ return d[1] })
    var xscl = d3.scale.linear().domain(range).range([0, w])
    var yscl = d3.scale.linear().domain([0, ymax]).nice().range([h, 0])
      .clamp(true)


    var line = d3.svg.line()
      .x(function(d) { return xscl(d[0]) })
      .y(function(d) { return yscl(d[1]) })

    path.transition().duration(1000).attr("d", function(d){
      kdearr.push([range[1], 0])
      kdearr.unshift([range[0], 0])
      return line(kdearr)
    })

    var ticks = yscl.ticks(5)
    var rules = svg.selectAll("g.rule").data(ticks)
    var newrules = rules.enter().append("g").attr("class", "rule")
    newrules.append("line").attr("x2", w).attr("stroke", "gray")
    newrules.append("text")
    rules.exit().remove()
    rules.attr("transform", function(d){return "translate(0," + yscl(d) + ")"})

    var ylabels = rules.selectAll("text")
    ylabels.attr("x", w + 5).attr("dy", ".35em")
      .text(formatFixedLen)

    var xlabels = xgroup.selectAll("text")
      .data([range[0], (range[0]+range[1])/2, range[1]])
    xlabels.enter().append("text")
      .attr("x", function(d, i){ return i * (w - 50)/2 })
      .attr("y", h + 10)
      .attr("dy", ".35em")
    xlabels.text(formatFixedLen)
  }

  this.destroy = function(){
    var g = KDEGraphUpdater.graphs
    for(i in g){
      if(g[i] == this){
        g.splice(i, 1)
        break
      }
    }
    svg.remove()
  }
}

KDEGraphUpdater.updateAll = function(){
  var g = KDEGraphUpdater.graphs
  for(i in g){
    g[i].update()
  }
}



function identity(d){
  return d
}

function formatDuration(t){
  if(t == 0)
    return "0"

  units = ["ns", "us", "ms"]
  for(var i = 0; i < 3; i++){
    if(t < 1000){
      return t.toString() + units[i]
    }
    t /= 1000
  }
  if(t < 60){
    return t.toString() + "s"
  }
  t /= 60
  return t.toString() + "m"
}

function formatFixedLen(n){
  if(isNaN(n))
    return n

  fix = n.toPrecision(6)
  if(fix.length <= 7){
    return fix
  } else {
    return n.toExponential(2)
  }
}


function dataRangeSlice(data, pmin, pmax, mul){
  var sorted = data.sort(function(a,b){return a-b})
  var imin = Math.floor(sorted.length*pmin)
  var imax = Math.ceil(sorted.length*pmax)
  var smin = sorted[imin]
  var smax = sorted[imax - 1]
  if(smin == smax){
    if(smax < 0){
      smin = 2 * smin
      smax = 0
    } else if(smax == 0){
      smin = -10
      smax = 10
    } else {
      smin = 0
      smax = 2 * smax
    }
  }

  var adj = (smax - smin) * (mul - 1)/2
  smax += adj
  smin -= adj

  return [[smin, smax], sorted.slice(imin, imax)]
}


$(document).ready(function(){
  $.getJSON("/list", {}, function(list){
    list.sort()
    for(i in list){
      new MetricRowUpdater(list[i][0], list[i][1])
    }

    $("#graphs").masonry({
      itemSelector: ".graph",
      columnWidth: 410
    })

    MetricRowUpdater.updateAll()
    setInterval(function(){MetricRowUpdater.updateAll()}, tableInterval)
    setInterval(function(){KDEGraphUpdater.updateAll()}, KDEInterval)
    setInterval(function(){HeatmapUpdater.updateAll()}, heatmapInterval)
  })

})

    </script>
  </body>

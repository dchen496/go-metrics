<html>
  <head>
    <title>{{.Name}} - Metrics Dashboard</title>
    <style>
      * {
        font-family: sans-serif;
        font-size: 10pt;
      }

      tr:nth-child(even){
        background-color:#e0e0e0
      }

      table {
        border-collapse: collapse;
      }

      td,th {
        border-left: 1px solid black;
        padding-left: 3px;
        padding-right: 3px;
      }

      th:first-child,
      td:first-child{
        border-left: 0;
      }

      div.horizon > canvas {
        display: block;
      }
      div.horizon > span.value {
        position: relative;
        left: 20px;
      }

      div.graph{
        float: left;
        width: 400px;
      }

    </style>
  </head>
  <body>
    <h3>{{.Name}} - Metrics Dashboard</h3>
    <div id="list"></div>
    <div id="metrics">
      <h3>Counters</h3>
      <table id="counters">
        <tr id="header"><th>Name</th><th>Value</th><th>Updated</th></tr>
      </table>
      <h3>Distributions</h3>
      <table id="distributions">
        <tr id="header">
          <th>Name</th>
          <th>Count</th>
          <th>Mean</th>
          <th>Variance</th>
          <th>StdDev</th>
          <th>Skewness</th>
          <th>Kurtosis</th>
          <th>Min</th>
          <th>Max</th>
          <th>Median</th>
          <th>25%</th>
          <th>75%</th>
          <th>99%</th>
          <th>99.9%</th>
        </tr>
      </table>
      <h3>Gauges</h3>
      <table id="gauges">
        <tr id="header"><th>Name</th><th>Value</th><th>Updated</th></tr>
      </table>
      <h3>Meters</h3>
      <table id="meters">
        <tr id="header"><th>Name</th><th>Value</th><th>Updated</th>
          <th>1 min</th><th>5 min</th><th>15 min</th>
          <th>Rates</th><th>1 min</th><th>5 min</th><th>15 min</th></tr>
      </table>
    </div>
    <h3>Graphs</h3>
    <div id="graphs"></div>
    <script src="http://d3js.org/d3.v2.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script src="https://raw.github.com/jasondavies/science.js/master/science.v1.min.js"></script>
    <script src="http://square.github.com/cubism/cubism.v1.js"></script>
    <script src="http://masonry.desandro.com/jquery.masonry.min.js"></script>
    <script>

metrics = []
counters = []
distributions = []
gauges = []
meters = []

tableInterval = 1000;
distributionSamplesInterval = 10000;
cubismContext = cubism.context()
    .serverDelay(1000).step(tableInterval).size(380);


function Metric(name, type){
  this.name = name;
  this.type = type;
  this.data = null;
  this.show = true;
  this.summary = null;
  this.graphs = {};
  this.graphdiv = null;
  this.graphcount = 0;

  this.update = function(){
    if(this.show == false){
      return null
    }

    var metric = this;

    return $.getJSON("/metric", {"name" : this.name},
      function(data){ metric.data = data.Value });
  }

  this.draw = function(){
    if(this.show == false){
      return null
    }

    switch(this.type){
    case "counter":
      this.drawCounter();
      break;
    case "distribution":
      this.drawDistribution();
      break;
    case "gauge":
      this.drawGauge();
      break;
    case "meter":
      this.drawMeter();
      break;
    }
  }

  this.drawCounter = function(){
    var counter = this.data;
    var updated = new Date(counter.LastUpdated);

    var data = [this.name,
      this.graphToggle(counter.Value, "Value",
        this.toggleCubism, "yellow"),
        updated.toLocaleTimeString()
      ];

    drawRow(this.summary, data)
  }

  this.drawDistribution = function(){
    var metric = this
    var d = metric.data;
    d["Min"] = d.Percentiles[0];
    d["p25"] = d.Percentiles[1];
    d["Median"] = d.Percentiles[2];
    d["p75"] = d.Percentiles[3];
    d["p99"] = d.Percentiles[4];
    d["p999"] = d.Percentiles[5];
    d["Max"] = d.Percentiles[6];

    var l = ["Mean", "Variance", "StandardDeviation", "Skewness",
      "Kurtosis", "Min", "Max", "Median", "p25", "p75", "p99", "p999"];

    var data = [
      this.graphToggle(this.name, "samples",
        this.toggleDistributionSamples, "lightsteelblue"),
      d.Count
    ]

    for(var i = 0; i < l.length; i++){
      data.push(this.graphToggle(d[l[i]], l[i],
        this.toggleCubism, "lightgreen"));
    }

    drawRow(this.summary, data)
  }

  this.toggleCubism = function(property){
    var metric = this;
    var context = cubismContext;
    var graph = this.graphs[property]

    var pd = graph.elem;
    if(this.graphs[property].show != true){
      if(pd != null){
        pd.select(".axis")
          .call(context.axis().remove).remove();
        pd.select(".horizon")
          .call(context.horizon().remove).remove();
        pd.select(".rule")
          .call(context.rule().remove).remove();
        pd.remove()
      }
      return;
    }

   //force cubism to synchronously update
    graph.queue = []
    var queue = graph.queue

    graph.metric = context.metric(
      function(start, stop, step, callback){
        start = +start;
        stop = +stop;

        var res = [];

        queue.push(metric.data[property]);
        if(queue.length > 7)
          queue.shift();

        while(start < stop){
          start += step;
          res.push(queue[i]);
        }
        callback(null, res);
      }, property);


    this.graphs[property].elem = this.graphdiv
      .append("div").attr("id", property)
    this.graphs[property].elem.call(function(div){

      div.html(null)
      div.append("div")
        .attr("class", "axis")
        .call(context.axis().ticks(d3.time.minutes, 2).orient("top"));

      div.selectAll(".horizon")
        .data([metric.graphs[property].metric])
        .enter().append("div")
        .attr("class", "horizon")
        .call(context.horizon());

      div.append("div")
        .data([])
        .attr("class", "rule")
        .call(context.rule());
    })

  }

  this.toggleDistributionSamples = function(){
    this.drawDistributionSamples();
  }

  this.drawDistributionSamples = function(){
    var w = 320, h = 240, wmargin = 80, hmargin = 40;
    var metric = this;
    if(this.graphs.samples.show != true){
      if(metric.graphs.samples.elem != null)
        metric.graphs.samples.elem.remove();
      return
    }

    var svg = metric.graphdiv.selectAll("svg#samples").data([1])
    svg.enter().append("svg").attr("id", "samples")
      .attr("width", w + wmargin)
      .attr("height", h + hmargin);
    metric.graphs.samples.elem = svg

    $.getJSON("/metric", {"name" : this.name, "samples" : true,
      "limit" : 1000}, function(d){

      var sorted = d.Value.sort(function(a,b){return a-b});
      var smin = sorted[Math.floor(sorted.length*0.1)];
      var smax = sorted[Math.ceil(sorted.length*0.9)-1];
      var adj = (smax - smin) * 0.5;
      smax += adj;
      smin -= adj;
      var diff = smax - smin

      var kde = science.stats.kde().sample(sorted);
      kde.bandwidth(science.stats.bandwidth.nrd0);
      var kdearr = kde(d3.range(smin, smax + diff/2/w, diff/w));

      ymax = d3.max(kdearr, function(d){ return d[1] });
      var xscl = d3.scale.linear().domain([smin, smax]).range([0, w])
      var yscl = d3.scale.linear().domain([0, ymax]).nice().range([h, 0])
        .clamp(true);


      var line = d3.svg.line()
        .x(function(d) { return xscl(d[0]); })
        .y(function(d) { return yscl(d[1]); });

      var paths = svg.selectAll("path")
        .data([1]);
      paths.enter().append("path").style("fill", "steelblue");
      paths.transition().duration(1000).attr("d", function(d){
        kdearr.push([smax, 0]);
        kdearr.unshift([smin, 0]);
        return line(kdearr);
      });

      var ticks = yscl.ticks(5);
      var rules = svg.selectAll("g.rule").data(ticks);
      var newrules = rules.enter().append("g").attr("class", "rule")
      newrules.append("line").attr("x2", w).attr("stroke", "gray");
      newrules.append("text")
      rules.exit().remove();
      rules.attr("transform",
        function(d){return "translate(0," + yscl(d) + ")"});

      var ylabels = rules.selectAll("text")
      ylabels.attr("x", w + 5).attr("dy", ".35em")
        .text(formatFixedLen)

      var xg = svg.selectAll("g#xlabel").data([xscl.domain()])
      xg.enter().append("g").attr("id", "xlabel")
      var xlabels = xg.selectAll("text").data(identity)
      xlabels.enter().append("text")
        .attr("x", function(d, i){ return i*(w-50) })
        .attr("y", h + 10)
        .attr("dy", ".35em")
      xlabels.text(formatFixedLen)

      setTimeout(function(){metric.drawDistributionSamples.call(metric)},
        distributionSamplesInterval);
    });

  }

  this.drawGauge = function(){
    var gauge = this.data;
    var updated = new Date(gauge.LastUpdated);
    var str;
    if(gauge.Value.length > 80) {
      str = slice(gauge.Value, 77) + "...";
    } else {
      str = gauge.Value
    }
    var data = [this.name, str, updated.toLocaleTimeString()];
    drawRow(this.summary, data)
  }

  this.drawMeter = function(){
    var meter = this.data;
    var updated = new Date(meter.LastUpdated);
    var avgs = this.data.Derivatives[0]
    var rates = this.data.Derivatives[1]
    meter.x1 = avgs[1]
    meter.x5 = avgs[2]
    meter.x15 = avgs[3]
    meter.dx_dt = rates[0]
    meter.dx_dt1 = rates[1]
    meter.dx_dt5 = rates[2]
    meter.dx_dt15 = rates[3]

    var data = [
      this.name,
      this.graphToggle(meter.Value, "Value", this.toggleCubism, "pink"),
      updated.toLocaleTimeString(),
    ];

    var l = ["x1", "x5", "x15", "dx_dt", "dx_dt1", "dx_dt5", "dx_dt15"];
    for(var i = 0; i < l.length; i++){
      data.push(this.graphToggle(meter[l[i]], l[i],
        this.toggleCubism, "pink"));
    }

    drawRow(this.summary, data)
  }

  this.graphToggle = function(text, property, onclick, color){
    var metric = this;
    if(this.graphs[property] == null){
      this.graphs[property] = {};
    }
    return clickableCell(text, function(c){
      if(metric.graphs[property].show){
        metric.graphcount--
        if(metric.graphcount == 0){
          metric.graphdiv.style("padding", "0");
          metric.graphdiv.select("h3#title").remove();
        }
        metric.graphs[property].show = false;
        c.style("background-color", "transparent");
      } else {
        metric.graphs[property].show = true;
        if(metric.graphcount == 0){
          metric.graphdiv.style("padding", "5px");
          metric.graphdiv.append("h3").attr("id", "title")
            .text(metric.name)
        }
        metric.graphcount++;
        c.style("background-color", color)
      }
      onclick.call(metric, property);
      updateGraphCols();
    })
  }
}


function identity(d){
  return d;
}

function formatDuration(t){
  if(t == 0)
    return "0";

  units = ["ns", "us", "ms"];
  for(var i = 0; i < 3; i++){
    if(t < 1000){
      return t.toString() + units[i];
    }
    t /= 1000;
  }
  if(t < 60){
    return t.toString() + "s";
  }
  t /= 60;
  return t.toString() + "m";
}

function formatFixedLen(n){
  if(isNaN(n))
    return n

  fix = n.toPrecision(6)
  if(fix.length <= 7){
    return fix
  } else {
    return n.toExponential(2);
  }
}

function drawRow(row, vals){
  var cells = row.selectAll("td").data(vals);
  cells.enter().append("td");
  cells.each(function(d){
    cell = d3.select(this);
    if($.isFunction(d)){
      d(cell);
    } else {
      if(!isNaN(d))
        d = formatFixedLen(d)
      cell.text(d);
    }
  });
}

function clickableCell(text, onclick){
  return function(c){
    if(!isNaN(text))
      text = formatFixedLen(text)
    c.text(text)
    c.on("click", function(){onclick(c)})
  }
}

function updateAll(){
  var deferred = []
  deferred.length = metrics.length

  for(i in metrics){
    deferred[i] = metrics[i].update();
  }

  $.when.apply($, deferred).then(function(){
    for(i in metrics){
      metrics[i].draw();
    }
  });
}

$(document).ready(function(){
  $.getJSON("/list", {}, function(list){
    list.sort()
    for(i in list){
      var m = new Metric(list[i][0], list[i][1]);
      metrics.push(m);
      switch(list[i][1]){
      case "counter":
        counters.push(m);
        break;
      case "distribution":
        distributions.push(m);
        break;
      case "gauge":
        gauges.push(m);
        break;
      case "meter":
        meters.push(m);
        break;
      }
    }

    populate("#counters", counters)
    populate("#distributions", distributions)
    populate("#gauges", gauges)
    populate("#meters", meters)

    d3.select("#graphs").selectAll("div").data(metrics)
    .enter().append("div").attr("class", "graph")
      .each(function(metric){
        metric.graphdiv = d3.select(this)
      });

    $("#graphs").masonry({
      itemSelector: ".graph",
      columnWidth: 410
    });

    metrics.forEach(function(metric){
      $.when(metric.update()).then(function(){ metric.draw() });
    })

    updateAll();
    setInterval(updateAll, tableInterval);

  });

});

function populate(selector, metrics){
  var sel = d3.select(selector).selectAll("tr.summary")
    .data(metrics).enter()

  sel.append("tr")
     .each(function(metric){
       metric.summary = d3.select(this);
     });
}

function updateGraphCols(){
  $("#graphs").masonry("reload");
}
    </script>
  </body>
